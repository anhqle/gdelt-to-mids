class(as.vector(a[1,]))
as.vector(a[1,])
as.vector(a[1,])[1]
unlist(a[1,])
class(unlist(a[1,]))
str(unlist(a[1,]))
f_isConflictual(unlist(a[1,]), temp)
undebug(f_isConflictual)
f_isConflictual(unlist(a[1,]), temp)
f_transformDispIntoDyad <- function(ref) {
dyadmonths <- f_genDyadMonthFromDisp(ref)
dyads_conflict <- data.frame(dyadmonths,
conflict=apply(dyadmonths, 1, f_isConflictual, ref),
stringsAsFactors=FALSE)
return(dyads_conflict)
}
f_isConflictual(a, temp)
f_transformDispIntoDyad(temp)
a
apply(a, 1, f_isConflictual, temp)
help(apply)
apply(a, 1, print(a[4]))
apply(a[ , c(3,4)], 1, sum)
a
f_transformDispIntoDyad <- function(ref) {
dyadmonths <- f_genDyadMonthFromDisp(ref)
dyads_conflict <- data.frame(dyadmonths,
conflict=adply(dyadmonths, 1, f_isConflictual, ref),
stringsAsFactors=FALSE)
return(dyads_conflict)
}
f_transformDispIntoDyad(temp)
adply(a, 1, f_isConflictual, temp)
names(a)
ddply(a, names(a), f_isConflictual, temp)
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1,1]
stateB <- dyadmonth[1,2]
year <- dyadmonth[1,3]
month <- dyadmonth[1,4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StartYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StartMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StartYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StartMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# What if countries switch side?
return(conflict)
}
f_isConflictual(a, temp)
adply(a, 1, f_isConflictual, temp)
ddply(a, names(a), f_isConflictual, temp)
apply(a, 1, f_isConflictual, temp)
f_isConflictual(a[1,])
f_isConflictual(a[1,], temp)
f_isConflictual(a[2,], temp)
f_isConflictual(a[3,], temp)
f_isConflictual(a[10,], temp)
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1]
stateB <- dyadmonth[2]
year <- dyadmonth[3]
month <- dyadmonth[4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StartYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StartMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StartYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StartMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# What if countries switch side?
return(conflict)
}
apply(a, 1, f_isConflictual, temp)
apply(a[,c(3,4)], 1, sum)
debug(f_isConflictual)
f_isConflictual(unlist(a[1,]), temp)
stateA
stateB
class(stateA)
class(month)
dyadmonth
head(a)
unlist(a[1,])
sapply(a, class)
apply(a[1,], 1, f_isConflictual, temp)
dyadmonth
sapply(dyadmonth, class)
q
adply(a, 1, f_isConflictual, temp)
sapply(dyadmonth, class)
adply(a, 1, f_isConflictual, temp)
undebug(f_isConflictual)
options(error=recover)
adply(a, 1, f_isConflictual, temp)
options(error=browser)
adply(a, 1, f_isConflictual, temp)
dyadmonth
stateA
debug(f_isConflictual)
adply(a, 1, f_isConflictual, temp)
dyadmonth
sapply(dyadmonth, class)
year
class(year)
temp
temp$EndYear[temp$StAbb==stateA]
stateA
temp$StAbb==stateA
temp$StAbb
temp$StAbb == "EGY"
class(stateA)
class(dyadmonth)
class(dyadmonth[1])
class(dyadmonth[1,1])
c("a", 1)
a[1]
a[,1]
a
a[1]
a[1,]
as.vector(a[1,])
class(as.vector(a[1,]))
a <- data.frame("a", "b", 1, 2)
a
as.vector(a)
class(as.vector(a))
class(as.vector(data.frame("a", 1)))
adply(a, 1, f_isConflictual, temp)
class(dyadmonth)
list(dyadmonth)
dyadmonth[1,1]
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
year <- dyadmonth[1, 3]
month <- dyadmonth[1, 4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StartYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StartMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StartYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StartMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# What if countries switch side?
return(conflict)
}
adply(a, 1, f_isConflictual, temp)
n
n
apply(a, 1, f_isConflictual, temp)
apply(a, 1, f_isConflictual, temp)
dyadmonth
class(dyadmonth)
ddply(a, names(a), f_isConflictual, temp)
adply(a, 1, f_isConflictual, temp)
adply(a, 1, class)
a
a <- f_genDyadMonthFromDisp(temp)
adply(a, 1, f_isConflictual, temp)
adply(a, 1, class)
undebug()
adply(a, 1, f_isConflictual, temp)
undebug(f_isConflictual)
options(error=NULL)
debug(f_isConflictual)
adply(a, 1, f_isConflictual, temp)
year
class(year)
class(stateA)
class(month)
re
ref
ref$EndYear[ref$StAbb==stateA]
ref$StAbb==stateA
year <= ref$EndYear[ref$StAbb==stateA]
year >= ref$StartYear[ref$StAbb==stateA]
ref$StartYear[ref$StAbb==stateA]
names(ref)
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
year <- dyadmonth[1, 3]
month <- dyadmonth[1, 4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# What if countries switch side?
return(conflict)
}
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
year <- dyadmonth[1, 3]
month <- dyadmonth[1, 4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# What if countries switch side?
return(conflict)
}
adply(a, 1, f_isConflictual, temp)
adply(a, 1, f_isConflictual, temp)
debug(f_isConflictual
)
adply(a, 1, f_isConflictual, temp)
matchMonthA
matchMonthB
ref$SideA[ref$StAbb==stateA][matchMonthA]
ref$SideA[ref$StAbb==stateA]
c()
c() != c()
adply(a, 1, f_isConflictual, temp)
ref$SideA[ref$StAbb==stateA][matchMonthA]
ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
a <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
a
as.numeric(a)
is.null(a)
a
length(a)
conflict <- ifelse(length(conflict==0), FALSE, conflict)
conflict <- ifelse(length(conflict==0), FALSE, conflict)
conflict
p
a
length(a==0)
conflict
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
year <- dyadmonth[1, 3]
month <- dyadmonth[1, 4]
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
matchMonthA <- (year <= ref$EndYear[ref$StAbb==stateA]) &
(year >= ref$StYear[ref$StAbb==stateA]) &
(month <= ref$EndMon[ref$StAbb==stateA]) &
(month >= ref$StMon[ref$StAbb==stateA])
matchMonthB <- (year <= ref$EndYear[ref$StAbb==stateB]) &
(year >= ref$StYear[ref$StAbb==stateB]) &
(month <= ref$EndMon[ref$StAbb==stateB]) &
(month >= ref$StMon[ref$StAbb==stateB])
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
conflict <- ifelse(length(conflict)==0, FALSE, conflict)
# What if countries switch side?
return(conflict)
}
adply(a, 1, f_isConflictual, temp)
temp
adply(a, 1, f_isConflictual, temp)
debug(f_isConflictual)
adply(a, 1, f_isConflictual, temp)
conflict
year
month
yewar
year
month
dyadmonth
dyadmonth
dyadmonth
dyadmonth
a
f_genDyadMonthFromDisp <- function(ref) {
years <- c(min(ref$StYear):max(ref$StYear))
months <- c(1:12)
month_years <- expand.grid(years, months, stringsAsFactors=FALSE)
countries <- as.character(unique(ref$StAbb))
dyads <- t(combn(countries, 2))
dyads <- data.frame(dyads[order(dyads[, 1], dyads[, 2]), ], stringsAsFactors=FALSE)
# Match each dyad with each month. Had to temporarily join 2 countries into 1 var
# (ideal?)
finalMatrix <- expand.grid(paste(dyads[,1], dyads[,2]),
paste(month_years[,1], month_years[,2]),
stringsAsFactors = FALSE)
finalMatrix2 <- data.frame(do.call(rbind, strsplit(finalMatrix$Var1, " ")),
do.call(rbind, strsplit(finalMatrix$Var2, " ")),
stringsAsFactors=FALSE)
names(finalMatrix2) <- c("stateA", "stateB", "year", "month")
finalMatrix2 <- transform(finalMatrix2, year = as.numeric(year),
month = as.numeric(month))
finalMatrix2 <- finalMatrix2[order(finalMatrix2$year, finalMatrix2$month),]
return(finalMatrix2)
}
a <- f_genDyadMonthFromDisp(temp)
a
adply(a, 1, f_isConflictual, temp)
dyadmonth
dyadmonth
dyamonth
dyadmonth
dyadmonth
dyadmonth
ref
dyadmonth
year
month
month
matchMonthA
ref$EndYear[ref$StAbb==stateA]
stateA
year <= ref$EndYear[ref$StAbb==stateA]
year >= ref$StYear[ref$StAbb==stateA]
dyadmonth
paste(year, month)
as.Date(paste(year, month))
as.Date(paste(year, month, sep="-")
)
as.Date(paste(year, month, sep="/", format="%Y/%m")
)
as.Date(paste(year, month, sep="/"), format="%Y/%m")
paste(year, monthm, sep="/")
paste(year, month, sep="/")
as.Date(paste(year, month, sep="/"), format="%Y/%m")
as.Date("1954/7", format="%Y/%m")
help(yearmon)
library(zoo)
install.packages("zoo")
help(yearmon)
help(as.yearmon)
library(zoo)
help(as.yearmon)
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
# year <- dyadmonth[1, 3]
# month <- dyadmonth[1, 4]
currentMonth <- as.yearmon(paste(dyadmonth[1, 3], dyadmonth[1, 4], sep="-"), format="%Y-%m")
# Check. Remember that in a dispute, a state may appear multiple times
# Check the month in dyad month matches with which row in the ref dataframe
# There should be only one match, i.e. matchMonthA is a logical vector with one element = T
stMonthA <- as.yearmon(paste(ref$StYear[ref$StAbb==stateA], ref$StMon[ref$StAbb==stateA],
sep="-"),
format="%Y-%m")
endMonthA <- as.yearmon(paste(ref$EndYear[ref$StAbb==stateA], ref$EndMon[ref$StAbb==stateA],
sep="-"),
format="%Y-%m")
matchMonthA <- (currentMonth >= stMonthA) & (currentMonth <= endMonthA)
stMonthB <- as.yearmon(paste(ref$StYear[ref$StAbb==stateB], ref$StMon[ref$StAbb==stateB],
sep="-"),
format="%Y-%m")
endMonthB <- as.yearmon(paste(ref$EndYear[ref$StAbb==stateB], ref$EndMon[ref$StAbb==stateB],
sep="-"),
format="%Y-%m")
matchMonthB <- (currentMonth >= stMonthB) & (currentMonth <= endMonthB)
# Check side
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
conflict <- ifelse(length(conflict)==0, FALSE, conflict)
# What if countries switch side?
return(conflict)
}
debug(f_isConflictual)
adply(a, 1, f_isConflictual, temp)
dyadmonth
dyadmonth
dyadmonth
dyadmonth
dyadmonth
dyadmonth
temp
dyadmonht
dyadmonth
temp
dyadmonth
temp
currentMonth
currentMonth >= stMonthA
conflict
adply(a, 1, f_isConflictual, temp)
undebug(f_isConflictual)
adply(a, 1, f_isConflictual, temp)
temp <- data[data$DispNum3==258, ]
temp
adply(a, 1, f_isConflictual, temp)
a <- f_genDyadMonthFromDisp(temp)
temp <- data[data$DispNum3==3429, ]
f_transformDispIntoDyad <- function(ref) {
dyadmonths <- f_genDyadMonthFromDisp(ref)
dyads_conflict <- adply(dyadmonths, 1, f_isConflictual, ref)
return(dyads_conflict)
}
f_transformDispIntoDyad(temp)
temp <- data[data$DispNum3==258, ]
temp
f_transformDispIntoDyad(temp)
res <- f_transformDispIntoDyad(temp)
head(res)
any(head$V1==TRUE)
any(res$V1==TRUE)
head(res[res$V1==TRUE])
head(res[res$V1==TRUE,])
View(temp)
rm(list=ls())
toLoad <- c("plyr", "countrycode", "dplyr", "data.table", "reshape2", "zoo")
lapply(toLoad, library, character.only=TRUE)
data <- read.csv("../data/MID/MIDB_4.0.csv", as.is=TRUE)
names(data)
# ---- Step 2: Transform dispute data into matrix of dyad month ----
# Create the matrix of conflictual dyad months from original data
# Test on one dispute. Then later apply these functions to all other disputes,
# using plyr
# Check if a dyadmonth is in conflict. Dyadmonth is a one row data frame
f_isConflictual <- function(dyadmonth, ref) {
stateA <- dyadmonth[1, 1]
stateB <- dyadmonth[1, 2]
currentMonth <- as.yearmon(paste(dyadmonth[1, 3], dyadmonth[1, 4], sep="-"), format="%Y-%m")
# Remember that in a dispute, a state may appear multiple times, in multiple rows. So,
# Check which row in the REFerence dataframe matches with currentMonth
# There should be only one match,
# i.e. matchMonthA is a logical vector with AT MOST one element = T
stMonthA <- as.yearmon(paste(ref$StYear[ref$StAbb==stateA], ref$StMon[ref$StAbb==stateA],
sep="-"), format="%Y-%m")
endMonthA <- as.yearmon(paste(ref$EndYear[ref$StAbb==stateA], ref$EndMon[ref$StAbb==stateA],
sep="-"), format="%Y-%m")
matchMonthA <- (currentMonth >= stMonthA) & (currentMonth <= endMonthA)
stMonthB <- as.yearmon(paste(ref$StYear[ref$StAbb==stateB], ref$StMon[ref$StAbb==stateB],
sep="-"), format="%Y-%m")
endMonthB <- as.yearmon(paste(ref$EndYear[ref$StAbb==stateB], ref$EndMon[ref$StAbb==stateB],
sep="-"), format="%Y-%m")
matchMonthB <- (currentMonth >= stMonthB) & (currentMonth <= endMonthB)
# Check side using the row/micro-conflict that matches currentMonth
# This ensures correct result even if countries switch side across rows/micro-conflicts
conflict <- ref$SideA[ref$StAbb==stateA][matchMonthA] !=
ref$SideA[ref$StAbb==stateB][matchMonthB]
# If the currentMonth does not match any row then conflict is length 0, so:
conflict <- ifelse(length(conflict)==0, FALSE, conflict)
return(conflict)
}
# Function that takes one dispute and turn into dyads conflict
f_genDyadMonthFromDisp <- function(ref) {
years <- c(min(ref$StYear):max(ref$StYear))
months <- c(1:12)
month_years <- expand.grid(years, months, stringsAsFactors=FALSE)
countries <- as.character(unique(ref$StAbb))
dyads <- t(combn(countries, 2))
dyads <- data.frame(dyads[order(dyads[, 1], dyads[, 2]), ], stringsAsFactors=FALSE)
# Match each dyad with each month. Had to temporarily join 2 countries into 1 var
# (ideal?)
finalMatrix <- expand.grid(paste(dyads[,1], dyads[,2]),
paste(month_years[,1], month_years[,2]),
stringsAsFactors = FALSE)
finalMatrix2 <- data.frame(do.call(rbind, strsplit(finalMatrix$Var1, " ")),
do.call(rbind, strsplit(finalMatrix$Var2, " ")),
stringsAsFactors=FALSE)
names(finalMatrix2) <- c("stateA", "stateB", "year", "month")
finalMatrix2 <- transform(finalMatrix2, year = as.numeric(year),
month = as.numeric(month))
finalMatrix2 <- finalMatrix2[order(finalMatrix2$year, finalMatrix2$month),]
return(finalMatrix2)
}
f_transformDispIntoDyad <- function(ref) {
dyadmonths <- f_genDyadMonthFromDisp(ref)
dyads_conflict <- adply(dyadmonths, 1, f_isConflictual, ref)
return(dyads_conflict)
}
temp <- data[data$DispNum3==258, ]
temp
res <- f_transformDispIntoDyad(temp)
res
system.time(res <- f_transformDispIntoDyad(temp))
help(system.time)
